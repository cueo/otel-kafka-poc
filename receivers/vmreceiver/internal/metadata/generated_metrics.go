// Code generated by mdatagen. DO NOT EDIT.

package metadata

import (
	"time"

	"go.opentelemetry.io/collector/component"
	"go.opentelemetry.io/collector/pdata/pcommon"
	"go.opentelemetry.io/collector/pdata/pmetric"
	"go.opentelemetry.io/collector/receiver"
)

type metricActive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills active metric with initial data.
func (m *metricActive) init() {
	m.data.SetName("active")
	m.data.SetDescription("Amount of active memory")
	m.data.SetUnit("bytes")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricActive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricActive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricActive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricActive(cfg MetricConfig) metricActive {
	m := metricActive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBlocksReceived struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills blocks_received metric with initial data.
func (m *metricBlocksReceived) init() {
	m.data.SetName("blocks_received")
	m.data.SetDescription("Blocks received from a block device per second")
	m.data.SetUnit("blocks")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricBlocksReceived) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBlocksReceived) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBlocksReceived) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBlocksReceived(cfg MetricConfig) metricBlocksReceived {
	m := metricBlocksReceived{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBlocksSent struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills blocks_sent metric with initial data.
func (m *metricBlocksSent) init() {
	m.data.SetName("blocks_sent")
	m.data.SetDescription("Blocks sent to a block device per second")
	m.data.SetUnit("blocks")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricBlocksSent) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBlocksSent) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBlocksSent) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBlocksSent(cfg MetricConfig) metricBlocksSent {
	m := metricBlocksSent{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricBuffered struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills buffered metric with initial data.
func (m *metricBuffered) init() {
	m.data.SetName("buffered")
	m.data.SetDescription("Amount of memory used as buffers")
	m.data.SetUnit("bytes")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricBuffered) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricBuffered) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricBuffered) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricBuffered(cfg MetricConfig) metricBuffered {
	m := metricBuffered{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricCached struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills cached metric with initial data.
func (m *metricCached) init() {
	m.data.SetName("cached")
	m.data.SetDescription("Amount of memory used as cache")
	m.data.SetUnit("bytes")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricCached) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricCached) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricCached) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricCached(cfg MetricConfig) metricCached {
	m := metricCached{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricContextSwitches struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills context_switches metric with initial data.
func (m *metricContextSwitches) init() {
	m.data.SetName("context_switches")
	m.data.SetDescription("Number of context switches per second")
	m.data.SetUnit("switches")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricContextSwitches) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricContextSwitches) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricContextSwitches) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricContextSwitches(cfg MetricConfig) metricContextSwitches {
	m := metricContextSwitches{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricFree struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills free metric with initial data.
func (m *metricFree) init() {
	m.data.SetName("free")
	m.data.SetDescription("Amount of idle memory")
	m.data.SetUnit("bytes")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricFree) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricFree) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricFree) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricFree(cfg MetricConfig) metricFree {
	m := metricFree{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIdleTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills idle_time metric with initial data.
func (m *metricIdleTime) init() {
	m.data.SetName("idle_time")
	m.data.SetDescription("Time spent idle")
	m.data.SetUnit("seconds")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIdleTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIdleTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIdleTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIdleTime(cfg MetricConfig) metricIdleTime {
	m := metricIdleTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricInactive struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills inactive metric with initial data.
func (m *metricInactive) init() {
	m.data.SetName("inactive")
	m.data.SetDescription("Amount of inactive memory")
	m.data.SetUnit("bytes")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricInactive) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricInactive) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricInactive) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricInactive(cfg MetricConfig) metricInactive {
	m := metricInactive{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricInterrupts struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills interrupts metric with initial data.
func (m *metricInterrupts) init() {
	m.data.SetName("interrupts")
	m.data.SetDescription("Number of interrupts per second, including the clock")
	m.data.SetUnit("interrupts")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricInterrupts) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricInterrupts) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricInterrupts) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricInterrupts(cfg MetricConfig) metricInterrupts {
	m := metricInterrupts{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricIoWaitTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills io_wait_time metric with initial data.
func (m *metricIoWaitTime) init() {
	m.data.SetName("io_wait_time")
	m.data.SetDescription("Time spent waiting for IO")
	m.data.SetUnit("seconds")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricIoWaitTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricIoWaitTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricIoWaitTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricIoWaitTime(cfg MetricConfig) metricIoWaitTime {
	m := metricIoWaitTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricRunnableProcs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills runnable_procs metric with initial data.
func (m *metricRunnableProcs) init() {
	m.data.SetName("runnable_procs")
	m.data.SetDescription("Number of runnable processes")
	m.data.SetUnit("processes")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricRunnableProcs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricRunnableProcs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricRunnableProcs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricRunnableProcs(cfg MetricConfig) metricRunnableProcs {
	m := metricRunnableProcs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricStolenTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills stolen_time metric with initial data.
func (m *metricStolenTime) init() {
	m.data.SetName("stolen_time")
	m.data.SetDescription("Time stolen from a virtual machine")
	m.data.SetUnit("seconds")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricStolenTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricStolenTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricStolenTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricStolenTime(cfg MetricConfig) metricStolenTime {
	m := metricStolenTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSwapIn struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills swap_in metric with initial data.
func (m *metricSwapIn) init() {
	m.data.SetName("swap_in")
	m.data.SetDescription("Amount of memory swapped in from disk")
	m.data.SetUnit("bytes")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSwapIn) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSwapIn) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSwapIn) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSwapIn(cfg MetricConfig) metricSwapIn {
	m := metricSwapIn{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSwapOut struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills swap_out metric with initial data.
func (m *metricSwapOut) init() {
	m.data.SetName("swap_out")
	m.data.SetDescription("Amount of memory swapped to a block device")
	m.data.SetUnit("bytes")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSwapOut) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSwapOut) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSwapOut) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSwapOut(cfg MetricConfig) metricSwapOut {
	m := metricSwapOut{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSwapped struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills swapped metric with initial data.
func (m *metricSwapped) init() {
	m.data.SetName("swapped")
	m.data.SetDescription("Amount of virtual memory used")
	m.data.SetUnit("bytes")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSwapped) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSwapped) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSwapped) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSwapped(cfg MetricConfig) metricSwapped {
	m := metricSwapped{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricSystemTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills system_time metric with initial data.
func (m *metricSystemTime) init() {
	m.data.SetName("system_time")
	m.data.SetDescription("Time spent running kernel code (system time)")
	m.data.SetUnit("seconds")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricSystemTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricSystemTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricSystemTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricSystemTime(cfg MetricConfig) metricSystemTime {
	m := metricSystemTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricTotalProcs struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills total_procs metric with initial data.
func (m *metricTotalProcs) init() {
	m.data.SetName("total_procs")
	m.data.SetDescription("Total number of processes")
	m.data.SetUnit("processes")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricTotalProcs) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricTotalProcs) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricTotalProcs) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricTotalProcs(cfg MetricConfig) metricTotalProcs {
	m := metricTotalProcs{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

type metricUserTime struct {
	data     pmetric.Metric // data buffer for generated metric.
	config   MetricConfig   // metric config provided by user.
	capacity int            // max observed number of data points added to the metric.
}

// init fills user_time metric with initial data.
func (m *metricUserTime) init() {
	m.data.SetName("user_time")
	m.data.SetDescription("Time spent running non-kernel code (user time, including nice time)")
	m.data.SetUnit("seconds")
	m.data.SetEmptyGauge()
	m.data.Gauge().DataPoints().EnsureCapacity(m.capacity)
}

func (m *metricUserTime) recordDataPoint(start pcommon.Timestamp, ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	if !m.config.Enabled {
		return
	}
	dp := m.data.Gauge().DataPoints().AppendEmpty()
	dp.SetStartTimestamp(start)
	dp.SetTimestamp(ts)
	dp.SetIntValue(val)
	dp.Attributes().PutStr("hostname", hostnameAttributeValue)
	dp.Attributes().PutStr("os", osAttributeValue)
	dp.Attributes().PutStr("arch", archAttributeValue)
	dp.Attributes().PutStr("type", typeAttributeValue)
}

// updateCapacity saves max length of data point slices that will be used for the slice capacity.
func (m *metricUserTime) updateCapacity() {
	if m.data.Gauge().DataPoints().Len() > m.capacity {
		m.capacity = m.data.Gauge().DataPoints().Len()
	}
}

// emit appends recorded metric data to a metrics slice and prepares it for recording another set of data points.
func (m *metricUserTime) emit(metrics pmetric.MetricSlice) {
	if m.config.Enabled && m.data.Gauge().DataPoints().Len() > 0 {
		m.updateCapacity()
		m.data.MoveTo(metrics.AppendEmpty())
		m.init()
	}
}

func newMetricUserTime(cfg MetricConfig) metricUserTime {
	m := metricUserTime{config: cfg}
	if cfg.Enabled {
		m.data = pmetric.NewMetric()
		m.init()
	}
	return m
}

// MetricsBuilder provides an interface for scrapers to report metrics while taking care of all the transformations
// required to produce metric representation defined in metadata and user config.
type MetricsBuilder struct {
	config                MetricsBuilderConfig // config of the metrics builder.
	startTime             pcommon.Timestamp    // start time that will be applied to all recorded data points.
	metricsCapacity       int                  // maximum observed number of metrics per resource.
	metricsBuffer         pmetric.Metrics      // accumulates metrics data before emitting.
	buildInfo             component.BuildInfo  // contains version information.
	metricActive          metricActive
	metricBlocksReceived  metricBlocksReceived
	metricBlocksSent      metricBlocksSent
	metricBuffered        metricBuffered
	metricCached          metricCached
	metricContextSwitches metricContextSwitches
	metricFree            metricFree
	metricIdleTime        metricIdleTime
	metricInactive        metricInactive
	metricInterrupts      metricInterrupts
	metricIoWaitTime      metricIoWaitTime
	metricRunnableProcs   metricRunnableProcs
	metricStolenTime      metricStolenTime
	metricSwapIn          metricSwapIn
	metricSwapOut         metricSwapOut
	metricSwapped         metricSwapped
	metricSystemTime      metricSystemTime
	metricTotalProcs      metricTotalProcs
	metricUserTime        metricUserTime
}

// metricBuilderOption applies changes to default metrics builder.
type metricBuilderOption func(*MetricsBuilder)

// WithStartTime sets startTime on the metrics builder.
func WithStartTime(startTime pcommon.Timestamp) metricBuilderOption {
	return func(mb *MetricsBuilder) {
		mb.startTime = startTime
	}
}

func NewMetricsBuilder(mbc MetricsBuilderConfig, settings receiver.CreateSettings, options ...metricBuilderOption) *MetricsBuilder {
	mb := &MetricsBuilder{
		config:                mbc,
		startTime:             pcommon.NewTimestampFromTime(time.Now()),
		metricsBuffer:         pmetric.NewMetrics(),
		buildInfo:             settings.BuildInfo,
		metricActive:          newMetricActive(mbc.Metrics.Active),
		metricBlocksReceived:  newMetricBlocksReceived(mbc.Metrics.BlocksReceived),
		metricBlocksSent:      newMetricBlocksSent(mbc.Metrics.BlocksSent),
		metricBuffered:        newMetricBuffered(mbc.Metrics.Buffered),
		metricCached:          newMetricCached(mbc.Metrics.Cached),
		metricContextSwitches: newMetricContextSwitches(mbc.Metrics.ContextSwitches),
		metricFree:            newMetricFree(mbc.Metrics.Free),
		metricIdleTime:        newMetricIdleTime(mbc.Metrics.IdleTime),
		metricInactive:        newMetricInactive(mbc.Metrics.Inactive),
		metricInterrupts:      newMetricInterrupts(mbc.Metrics.Interrupts),
		metricIoWaitTime:      newMetricIoWaitTime(mbc.Metrics.IoWaitTime),
		metricRunnableProcs:   newMetricRunnableProcs(mbc.Metrics.RunnableProcs),
		metricStolenTime:      newMetricStolenTime(mbc.Metrics.StolenTime),
		metricSwapIn:          newMetricSwapIn(mbc.Metrics.SwapIn),
		metricSwapOut:         newMetricSwapOut(mbc.Metrics.SwapOut),
		metricSwapped:         newMetricSwapped(mbc.Metrics.Swapped),
		metricSystemTime:      newMetricSystemTime(mbc.Metrics.SystemTime),
		metricTotalProcs:      newMetricTotalProcs(mbc.Metrics.TotalProcs),
		metricUserTime:        newMetricUserTime(mbc.Metrics.UserTime),
	}
	for _, op := range options {
		op(mb)
	}
	return mb
}

// updateCapacity updates max length of metrics and resource attributes that will be used for the slice capacity.
func (mb *MetricsBuilder) updateCapacity(rm pmetric.ResourceMetrics) {
	if mb.metricsCapacity < rm.ScopeMetrics().At(0).Metrics().Len() {
		mb.metricsCapacity = rm.ScopeMetrics().At(0).Metrics().Len()
	}
}

// ResourceMetricsOption applies changes to provided resource metrics.
type ResourceMetricsOption func(pmetric.ResourceMetrics)

// WithResource sets the provided resource on the emitted ResourceMetrics.
// It's recommended to use ResourceBuilder to create the resource.
func WithResource(res pcommon.Resource) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		res.CopyTo(rm.Resource())
	}
}

// WithStartTimeOverride overrides start time for all the resource metrics data points.
// This option should be only used if different start time has to be set on metrics coming from different resources.
func WithStartTimeOverride(start pcommon.Timestamp) ResourceMetricsOption {
	return func(rm pmetric.ResourceMetrics) {
		var dps pmetric.NumberDataPointSlice
		metrics := rm.ScopeMetrics().At(0).Metrics()
		for i := 0; i < metrics.Len(); i++ {
			switch metrics.At(i).Type() {
			case pmetric.MetricTypeGauge:
				dps = metrics.At(i).Gauge().DataPoints()
			case pmetric.MetricTypeSum:
				dps = metrics.At(i).Sum().DataPoints()
			}
			for j := 0; j < dps.Len(); j++ {
				dps.At(j).SetStartTimestamp(start)
			}
		}
	}
}

// EmitForResource saves all the generated metrics under a new resource and updates the internal state to be ready for
// recording another set of data points as part of another resource. This function can be helpful when one scraper
// needs to emit metrics from several resources. Otherwise calling this function is not required,
// just `Emit` function can be called instead.
// Resource attributes should be provided as ResourceMetricsOption arguments.
func (mb *MetricsBuilder) EmitForResource(rmo ...ResourceMetricsOption) {
	rm := pmetric.NewResourceMetrics()
	ils := rm.ScopeMetrics().AppendEmpty()
	ils.Scope().SetName("otelcol/vmreceiver")
	ils.Scope().SetVersion(mb.buildInfo.Version)
	ils.Metrics().EnsureCapacity(mb.metricsCapacity)
	mb.metricActive.emit(ils.Metrics())
	mb.metricBlocksReceived.emit(ils.Metrics())
	mb.metricBlocksSent.emit(ils.Metrics())
	mb.metricBuffered.emit(ils.Metrics())
	mb.metricCached.emit(ils.Metrics())
	mb.metricContextSwitches.emit(ils.Metrics())
	mb.metricFree.emit(ils.Metrics())
	mb.metricIdleTime.emit(ils.Metrics())
	mb.metricInactive.emit(ils.Metrics())
	mb.metricInterrupts.emit(ils.Metrics())
	mb.metricIoWaitTime.emit(ils.Metrics())
	mb.metricRunnableProcs.emit(ils.Metrics())
	mb.metricStolenTime.emit(ils.Metrics())
	mb.metricSwapIn.emit(ils.Metrics())
	mb.metricSwapOut.emit(ils.Metrics())
	mb.metricSwapped.emit(ils.Metrics())
	mb.metricSystemTime.emit(ils.Metrics())
	mb.metricTotalProcs.emit(ils.Metrics())
	mb.metricUserTime.emit(ils.Metrics())

	for _, op := range rmo {
		op(rm)
	}
	if ils.Metrics().Len() > 0 {
		mb.updateCapacity(rm)
		rm.MoveTo(mb.metricsBuffer.ResourceMetrics().AppendEmpty())
	}
}

// Emit returns all the metrics accumulated by the metrics builder and updates the internal state to be ready for
// recording another set of metrics. This function will be responsible for applying all the transformations required to
// produce metric representation defined in metadata and user config, e.g. delta or cumulative.
func (mb *MetricsBuilder) Emit(rmo ...ResourceMetricsOption) pmetric.Metrics {
	mb.EmitForResource(rmo...)
	metrics := mb.metricsBuffer
	mb.metricsBuffer = pmetric.NewMetrics()
	return metrics
}

// RecordActiveDataPoint adds a data point to active metric.
func (mb *MetricsBuilder) RecordActiveDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricActive.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordBlocksReceivedDataPoint adds a data point to blocks_received metric.
func (mb *MetricsBuilder) RecordBlocksReceivedDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricBlocksReceived.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordBlocksSentDataPoint adds a data point to blocks_sent metric.
func (mb *MetricsBuilder) RecordBlocksSentDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricBlocksSent.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordBufferedDataPoint adds a data point to buffered metric.
func (mb *MetricsBuilder) RecordBufferedDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricBuffered.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordCachedDataPoint adds a data point to cached metric.
func (mb *MetricsBuilder) RecordCachedDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricCached.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordContextSwitchesDataPoint adds a data point to context_switches metric.
func (mb *MetricsBuilder) RecordContextSwitchesDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricContextSwitches.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordFreeDataPoint adds a data point to free metric.
func (mb *MetricsBuilder) RecordFreeDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricFree.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordIdleTimeDataPoint adds a data point to idle_time metric.
func (mb *MetricsBuilder) RecordIdleTimeDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricIdleTime.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordInactiveDataPoint adds a data point to inactive metric.
func (mb *MetricsBuilder) RecordInactiveDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricInactive.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordInterruptsDataPoint adds a data point to interrupts metric.
func (mb *MetricsBuilder) RecordInterruptsDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricInterrupts.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordIoWaitTimeDataPoint adds a data point to io_wait_time metric.
func (mb *MetricsBuilder) RecordIoWaitTimeDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricIoWaitTime.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordRunnableProcsDataPoint adds a data point to runnable_procs metric.
func (mb *MetricsBuilder) RecordRunnableProcsDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricRunnableProcs.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordStolenTimeDataPoint adds a data point to stolen_time metric.
func (mb *MetricsBuilder) RecordStolenTimeDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricStolenTime.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordSwapInDataPoint adds a data point to swap_in metric.
func (mb *MetricsBuilder) RecordSwapInDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricSwapIn.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordSwapOutDataPoint adds a data point to swap_out metric.
func (mb *MetricsBuilder) RecordSwapOutDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricSwapOut.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordSwappedDataPoint adds a data point to swapped metric.
func (mb *MetricsBuilder) RecordSwappedDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricSwapped.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordSystemTimeDataPoint adds a data point to system_time metric.
func (mb *MetricsBuilder) RecordSystemTimeDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricSystemTime.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordTotalProcsDataPoint adds a data point to total_procs metric.
func (mb *MetricsBuilder) RecordTotalProcsDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricTotalProcs.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// RecordUserTimeDataPoint adds a data point to user_time metric.
func (mb *MetricsBuilder) RecordUserTimeDataPoint(ts pcommon.Timestamp, val int64, hostnameAttributeValue string, osAttributeValue string, archAttributeValue string, typeAttributeValue string) {
	mb.metricUserTime.recordDataPoint(mb.startTime, ts, val, hostnameAttributeValue, osAttributeValue, archAttributeValue, typeAttributeValue)
}

// Reset resets metrics builder to its initial state. It should be used when external metrics source is restarted,
// and metrics builder should update its startTime and reset it's internal state accordingly.
func (mb *MetricsBuilder) Reset(options ...metricBuilderOption) {
	mb.startTime = pcommon.NewTimestampFromTime(time.Now())
	for _, op := range options {
		op(mb)
	}
}
